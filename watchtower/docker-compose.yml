# This is run via Portainer

services:  
  watchtower:
    image: containrrr/watchtower:latest
    container_name: watchtower
    hostname: watchtower
    network_mode: bridge
    restart: unless-stopped
    secrets:
      # Unsure if this is standard, but watchtower is treating these secrets as the references to
      # the actual files, not the contents of the files. This is why the file paths are used in the
      # environment variables below - eg /run/secrets/<secret_name>
      - watchtower_discord_API    # use for discord notifications
      # use for email notifications
      - email_server_account
      - email_server_password
      
    ## Variable Substitution
    # If deploying this directly via `docker compose up` or from GitHub via Portainer, make sure the .env file is in the 
    # same folder as the service's docker-compose.yml file. Docker / Portainer will then load the values from the .env 
    # file and subsitute them into the compose file wherever the ${VAR_NAME} is found.
    # 
    # If deploying this from Portainer via their WebUI, variable substitution via an .env file will not be available.
    # In this case, load the .env file via Portainer when building the stack. This will load the variables
    # directly into the container, without passing them through the compose file - aka no variable substitution.    
    
    # Uncomment the below only if deploying locally via Portainer and loading variables from .env file
    #env_file:
    #  - stack.env

    environment:
      # Setting via variable substitution from .env file
      # Comment these lines out if deploying locally via Portainer and loading variables from .env file
      PUID: 1002  # not respecting PUID set via .env file
      GUID: 1002  # not respecting GUID set via .env file
      TZ: ${TZ}

      WATCHTOWER_CLEANUP: true
      WATCHTOWER_INCLUDE_RESTARTING: true
      WATCHTOWER_INCLUDE_STOPPED: true
      WATCHTOWER_REVIVE_STOPPED: false
      WATCHTOWER_NO_RESTART: false
      WATCHTOWER_TIMEOUT: 30s              # give 30s for container to gracefully stop
      WATCHTOWER_SCHEDULE: 0 0 4 * * *     # run at 4am every day
      #WATCHTOWER_POLL_INTERVAL: 30
      WATCHTOWER_DEBUG: false
      WATCHTOWER_MONITOR_ONLY: false       # do not update containers, only notify
      
      # For email notifications
      # see https://www.digitalocean.com/community/tutorials/how-to-automatically-update-docker-container-images-with-watchtower-on-ubuntu-22-04
      WATCHTOWER_NOTIFICATIONS: email
      #WATCHTOWER_NOTIFICATION_EMAIL_FROM: /run/secrets/email_server_account
      WATCHTOWER_NOTIFICATION_EMAIL_FROM: ${EMAIL_FROM}
      WATCHTOWER_NOTIFICATION_EMAIL_TO: ${EMAIL_TO}
      WATCHTOWER_NOTIFICATION_EMAIL_SERVER: ${EMAIL_SERVER_HOST}
      WATCHTOWER_NOTIFICATION_EMAIL_SERVER_PORT: ${EMAIL_SERVER_PORT}
      WATCHTOWER_NOTIFICATION_EMAIL_SERVER_USER: ${EMAIL_FROM}
      WATCHTOWER_NOTIFICATION_EMAIL_SERVER_PASSWORD: /run/secrets/email_server_password  # using app password
      
      # For Notifiarr / discord notifications
      WATCHTOWER_NOTIFICATION_REPORT: true
      WATCHTOWER_NOTIFICATION_URL: /run/secrets/watchtower_discord_API
      WATCHTOWER_NOTIFICATION_TEMPLATE: |
        {{- if .Report -}}
          {{- with .Report -}}
        {{len .Scanned}} Scanned, {{len .Updated}} Updated, {{len .Failed}} Failed
              {{- range .Updated}}
        - {{.Name}} ({{.ImageName}}): {{.CurrentImageID.ShortID}} updated to {{.LatestImageID.ShortID}}
              {{- end -}}
              {{- range .Fresh}}
        - {{.Name}} ({{.ImageName}}): {{.State}}
            {{- end -}}
            {{- range .Skipped}}
        - {{.Name}} ({{.ImageName}}): {{.State}}: {{.Error}}
            {{- end -}}
            {{- range .Failed}}
        - {{.Name}} ({{.ImageName}}): {{.State}}: {{.Error}}
            {{- end -}}
          {{- end -}}
        {{- else -}}
          {{range .Entries -}}{{.Message}}{{"\n"}}{{- end -}}
        {{- end -}}
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
    # the 'command' flag not needed if wanting to watch all active containers
    #command: --interval 30 portainer watchtower 

# Using the secrets workaround from https://blog.mikesir87.io/2017/05/using-docker-secrets-during-development/
secrets:
  email_server_account:
    file: ${MOUNT_POINT}/secrets/email_server_account
  email_server_password:
    file: ${MOUNT_POINT}/secrets/email_server_password
  
  watchtower_discord_API:
    file: ${MOUNT_POINT}/secrets/notifiarr_watchtower_api
