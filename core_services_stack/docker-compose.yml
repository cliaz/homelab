# docker-compose for Stack of Swag + Homarr + HomeAssistant + WyzeBridge
# need to modify the swag configs in /data/docker/swag/config/nginx/proxy-confs/ to match

x-extra_hosts:
  # This is added so that within each service you can communicate to another service by using the DNS name of the host rather
  # than using IP address. Makes it easy if the IP address changes. For example, when configuring Radarr, you can
  # configure the transmission client url as http://host-server:9091
  &host-server
  # Pulls the IP address of the host from the .env file
  - "host-server:${HOST_IP}"

services:
  ## (Required - Option 1) Means of securely exposing internal services to the internet
  # SWAG reverse proxy for all services hosted on the docker host
  # services are exposed via the domain name sent through the URL, configured via the conf files in swag's nginx 
  swag:
    image: linuxserver/swag:latest    # https://docs.linuxserver.io/general/swag/#docker-compose
    container_name: swag
    hostname: swag
    extra_hosts: *host-server
    restart: unless-stopped
    cap_add:
      - NET_ADMIN
    networks: # needs all networks to be able to route to all services, mainly to support reaching containers via dns names without ports
      - core_services_net
      - media_net
      - download_net
      - ebooks_net
    ports:
      # - 80:80  # only needed if using http validation. We're using DNS validation with duckdns to validate, so don't need this
      - 81:81   # swag-dashboard mod
      - 443:443
    secrets:
      - DUCKDNSTOKEN
    environment:
      PUID: ${SWAG_UID:?Please configure SWAG_UID in .env file}
      PGID: ${SWAG_GID:?Please configure SWAG_GID in .env file}
      TZ: ${TZ:-Australia/Melbourne}
      URL: ${SWAG_URL:?Please configure SWAG_URL in .env file}

      SUBDOMAINS: wildcard
      VALIDATION: duckdns
      FILE__DUCKDNSTOKEN: /run/secrets/DUCKDNSTOKEN   # DuckDNS api token to facilitate DNS validation 
      # https://letsencrypt.org/docs/challenge-types/#dns-01-challenge
      #CERTPROVIDER: zerossl  # defaults to letsencrypt
      #EMAIL:   # required when using zerossl as cert provider
      DOCKER_MODS: linuxserver/mods:swag-auto-reload|linuxserver/mods:swag-dashboard
    volumes:
      - ${CONFIG_DIR}/swag:/config 

  ## (Required - Option 2) Means of securely exposing internal services to the internet
  # Cloudflare tunnel for exposing services without a public IP, aka when behind CGNAT
  # This can be used INSTEAD of the swag service to expose services to the internet.
  # It can also be used WITH the swag service, where the cloudflare config just points 
  # everything to swag, and then swag handles the routing to the correct service. Kinda redundant, but does give
  # SSL through the whole chain.
  
  cloudflared:
    image: cloudflare/cloudflared
    container_name: cloudflare
    hostname: cloudflare
    extra_hosts: *host-server
    restart: unless-stopped
    user: ${CLOUDFLARE_UID:?Please configure CLOUDFLARE_UID in .env file}:${CLOUDFLARE_GID:?Please configure CLOUDFLARE_GID in .env file}
    # networks:     # because we're currently still routing everything through swag, this container doesn't need to be aware of any other services
    #   - media_net
    secrets:    # see secrets section below
      - CLOUDFLARE_TOKEN
    environment:
      #PUID: ${CLOUDFLARED_UID:?Please configure CLOUDFLARED_UID in .env file}
      #PGID: ${CLOUDFLARED_GID:?Please configure CLOUDFLARED_GID in .env file}
      TZ: ${TZ:-Australia/Melbourne}
      TUNNEL_TOKEN_FILE: /run/secrets/CLOUDFLARE_TOKEN
    command: tunnel --no-autoupdate run 
  

  ## (Optional) Internal DNS and ad blocking
  # AdGuard Home for internal DNS and ad blocking
  adguardhome:
    image: adguard/adguardhome
    container_name: adguardhome
    hostname: adguardhome
    extra_hosts: *host-server
    #network_mode: host  # ADH needs to access the host network stack to run a DHCP server
    restart: unless-stopped
    networks:
      - core_services_net
    ports:
      # Plain DNS
      - '53:53/tcp'
      - '53:53/udp'
      # AdGuard Home Admin Panel as well as DNS-over-HTTPS
      - '82:80/tcp'
      #- '443:4443/tcp'
      #- '443:4443/udp'
      #- '3000:3000/tcp'
      # DNS-over-TLS
      #- '853:853/tcp'
      # DNS-over-QUIC
      #- '784:784/udp'
      #- '853:853/udp'
      #- '8853:8853/udp'
      # DNSCrypt
      #- '5443:5443/tcp'
      #- '5443:5443/udp'
      # Uncomment the below ports if you want to use AdGuard Home as a DHCP server
      #- 67:67/udp     # DHCP
      #- 68:68/udp     # DHCP
      #- 68:68/tcp     # DHCP
    environment:
      PUID: ${ADGUARDHOME_UID:?Please configure ADGUARDHOME_UID in .env file}
      PGID: ${ADGUARDHOME_GID:?Please configure ADGUARDHOME_GID in .env file}
      TZ: ${TZ:-Australia/Melbourne}
    volumes:
      - ${CONFIG_DIR}/adguard/work:/opt/adguardhome/work
      - ${CONFIG_DIR}/adguard/conf:/opt/adguardhome/conf

  ## (Optional) Home page for all services
  homarr:
    image: ghcr.io/homarr-labs/homarr:latest
    container_name: homarr
    hostname: homarr
    extra_hosts: *host-server
    restart: unless-stopped
    networks:
      - core_services_net
      - media_net
      - download_net
      - ebooks_net
    ports:
      - 7575:7575
    environment:
      PUID: ${HOMARR_UID:?Please configure HOMARR_UID in .env file}
      PGID: ${HOMARR_GID:?Please configure HOMARR_GID in .env file}
      TZ: ${TZ:-Australia/Melbourne}
      DISABLE_ANALYTICS: TRUE
      SECRET_ENCRYPTION_KEY: 524166404529ecf1673f7bc38e778fbfd9e60eae023af2f2667ad3e93b040ea5 # can be any random string, used to encrypt sensitive data in the database. #TODO: make this a secret
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock # Optional, only if you want docker integration. If so, make sure that the PUID or PGID configured in the .env file has permission to access the docker socket
      - ${CONFIG_DIR}/homarr/appdata:/appdata

  ## (Optional) Notification Aggregator
  # A notification aggregator that is used to send watchtower / sonarr / radarr etc. notifications to discord
  # also used to facilitate Trash-Guides sync for sonarr / radarr via a GUI.
  notifiarr:
    image: golift/notifiarr
    container_name: notifiarr
    hostname: notifiarr
    extra_hosts: *host-server
    restart: unless-stopped
    user: ${NOTIFIARR_UID:?Please configure NOTIFIARR_UID in .env file}:${NOTIFIARR_GID:?Please configure NOTIFIARR_GID in .env file}
    networks:
      - media_net   # unsure if notifiarr needs to be on the media_net network, but it's a media service so it's here for now
    ports:
      - 5454:5454
    environment:
      TZ: ${TZ:-Australia/Melbourne}
    volumes:
      - ${CONFIG_DIR:?Please configure CONFIG_DIR in .env file}/notifiarr:/config
      - /var/run/utmp:/var/run/utmp
      - /etc/machine-id:/etc/machine-id

  ## (Optional) View Wyze cameras streams internally instead of via the internet
  # Bridge to allow Wyze cameras to be used in HomeAssistant via RTSP. https://github.com/mrlt8/docker-wyze-bridge
  wyze-bridge:
    image: mrlt8/wyze-bridge:latest
    container_name: wyze-bridge
    hostname: wyze-bridge
    extra_hosts: *host-server
    restart: unless-stopped
    # This container needs to run as root, else it throws lots of errors
    #user: ${WYZEBRIDGE_UID:?Please configure WYZEBRIDGE_UID in .env file}:${WYZEBRIDGE_GID:?Please configure WYZEBRIDGE_GID in .env file}
    networks:
      - core_services_net
    ports:
      # TODO: harden ports
      #- 1935:1935 # RTMP - worst. probably don't want this
      - 8554:8554 # RTSP - next best. 
      - 8888:8888 # HLS - 2nd best. Working on the wyzecam v3
      #- 8889:8889 # WebRTC - best. Doesn't seem to be working on the wyzecam v3 though
      - 8189:8189/udp # WebRTC/ICE
      - 5000:5000 # WEB-UI
    secrets:
      # Due to the way that the fix for having secrets referenced via files was implemented (see
      # https://github.com/mrlt8/docker-wyze-bridge/issues/1244), if these these secrets exist they are read directly.
      # no need to set them in the environment variables
      - WYZE_EMAIL
      - WYZE_PASSWORD
      - API_ID
      - API_KEY
      - WB_USERNAME
      - WB_PASSWORD
    environment:
      TZ: ${TZ:-Australia/Melbourne}

      # [OPTIONAL] Credentials can be set in the WebUI, but every time the container is restarted, the credentials will need to be re-entered.
      # instead, they are now all set via secrets and read from /run/secrets as per https://github.com/mrlt8/docker-wyze-bridge/issues/1244

      # API Key and ID can be obtained from the wyze dev portal: 
      # https://developer-api-console.wyze.com/#/apikey/view

      # [OPTIONAL] IP Address of the host to enable WebRTC e.g.,:
      WB_IP: host-server

## Networks
# want to define a network range so that we can explicitly trust that network in the homeassistant config
networks:
  core_services_net:
    name: core_services_net   # ensure network isn't prefixed with the default name of the directory, eg git_core_services_stack_core_services_net
    attachable: true
    ipam:
      config:
        - subnet: 172.16.0.0/24
  download_net:
    name: download_net
    attachable: true
    ipam:
      config:
        - subnet: 172.16.1.0/24
  media_net:
    name: media_net
    attachable: true
    ipam:
      config:
        - subnet: 172.16.2.0/24
  ebooks_net:
    name: ebooks_net
    attachable: true
    ipam:
      config:
        - subnet: 172.16.3.0/24

  # I think there is an option to have the cloudflare container on its own network, and then only expose the services that need to be
  # be exposed to the internet via the cloudflare tunnel. For the moment, putting cloudflared on the core_services_net network
  # cloudflared:
  #   name: cloudflared

secrets:
  DUCKDNSTOKEN:
    file: ${SECRETS}/swag/duckdns_token
  CLOUDFLARE_TOKEN:
    file: ${SECRETS}/cloudflare/cloudflare_tunnel_token
  WYZE_EMAIL:
    file: ${SECRETS}/wyzebridge/wyze_account_email
  WYZE_PASSWORD:
    file: ${SECRETS}/wyzebridge/wyze_account_password
  API_ID:
    file: ${SECRETS}/wyzebridge/wyze_api_id
  API_KEY:
    file: ${SECRETS}/wyzebridge/wyze_api_key
  WB_USERNAME:
    file: ${SECRETS}/wyzebridge/wyze_bridge_webapp_username
  WB_PASSWORD:
    file: ${SECRETS}/wyzebridge/wyze_bridge_webapp_password

